---
import { ArrowLeft, ArrowRight } from "lucide-react";
import LocationMark from "./LocationMark.astro";
import data from "./location.json" assert { type: "json" };
import type { Location } from "./types";

const rawLocations = data.locations as Location[];

const navArticleWidth = "130px";
const visibleFrame = "120px";

const totalPages = rawLocations.length;
const locations = rawLocations.map((loc, i) => {
  // page et labelpage at build time
  const page = i + 1;
  const labelPage = page < 10 ? `0${page}` : page;
  return {
    ...loc,
    page: page,
    labelPage: labelPage,
    selected: i === 0,
  };
});
---

<script>
  /**
   * DEBUG SHOW GRID ( uncomment to show grid)
   */

  // const canvas = document.querySelector("#locationCanvas") as HTMLCanvasElement;
  // const ctx = canvas.getContext("2d")!;
  // const hideGrid = canvas.dataset.hidden;
  // canvas.width = width;
  // canvas.height = height;

  // const drawGrid = () => {
  //   const nRows = Math.floor(width / cellWidth);
  //   const nCols = Math.floor(height / cellHeight);

  //   // GRID DEEP LVL 1 INDEX IS ROW NUMBER
  //   // GRID DEEP LVL 2 INDEX IS COLUMN NUMBER
  //   const grid = new Array(nRows).fill(null).map(() => new Array(nCols).map((_, j) => j));
  //   // console.log(grid)
  //   ctx.strokeStyle = "rgba(255, 255, 255, 0.1)";
  //   ctx.lineWidth = 1;
  //   ctx.beginPath();
  //   for (let i = 0; i < grid.length; i++) {
  //     const row = grid[i] as number[];
  //     for (let j = 0; j < row.length; j++) {
  //       ctx.rect(j * cellWidth, i * cellHeight, cellWidth, cellHeight);
  //       ctx.strokeText(`${i},${j}`, j * cellWidth + 5, i * cellHeight + 15);
  //     }
  //   }
  //   ctx.stroke();
  // };
  // if (!hideGrid) drawGrid();

  const ctn = document.querySelector("#canvas-ctn") as HTMLElement;
  const marks = Array.from(document.querySelectorAll("[data-coor]")) as HTMLElement[];

  const cells = 30;
  const dimensions = {
    width: ctn.clientWidth,
    height: ctn.clientHeight,
    cellWidth: Math.floor(ctn.clientWidth / cells),
    cellHeight: Math.floor(ctn.clientHeight / cells),
    update: function () {
      this.width = ctn.clientWidth;
      this.height = ctn.clientHeight;
      this.cellWidth = Math.floor(this.width / cells);
      this.cellHeight = Math.floor(this.height / cells);
    },
  };

  const placeMarks = (mark: HTMLElement) => {
    const [x, y] = (mark.dataset.coor as string).split(",").map((n) => parseInt(n)) as [number, number];
    mark.style.top = `${y * dimensions.cellHeight}px`;
    mark.style.left = `${x * dimensions.cellWidth}px`;
  };

  marks.map((mark) => placeMarks(mark));

  window.onresize = () => {
    dimensions.update();
    marks.map((mark) => placeMarks(mark));
  };

  /**
   * Button script
   */
  const buttons = Array.from(document.querySelectorAll("[data-is='map-nav']"));
  const frame = document.querySelector("[data-is='frame']") as HTMLElement;
  const translation = parseInt(frame.dataset.translation as string, 10);

  const handler = (e: MouseEvent) => {
    const [action, currentTarget, totalPages] = (e.currentTarget as HTMLElement)?.dataset?.action
      ?.split("#")
      .map((x, i) => (i >= 1 ? parseInt(x) : x)) as [string, number, number];

    const targetIndex = action === "next" ? currentTarget + 1 : currentTarget - 1;
    const validTargetIndex = targetIndex > totalPages ? 1 : targetIndex < 1 ? totalPages : targetIndex;

    frame.style.transform = `translateX(-${(validTargetIndex - 1) * translation}px)`;
  };

  buttons &&
    buttons.map((btn) => {
      btn.addEventListener("click", handler as EventListener);
    });
</script>

<style define:vars={{ totalPages, navArticleWidth }}>
  button > * {
    @apply h-5 w-5 opacity-90;
  }

  [data-is="frame"] {
    min-width: calc(var(--navArticleWidth) * var(--totalPages));
    transition: transform 0.3s;
  }
</style>
<!--   -->
<div
  class="absolute top-0 left-1/4 overflow-x-hidden"
  style={`max-width: ${visibleFrame}; width: ${visibleFrame}; height: 100%;`}
>
  <div class="horizontal" data-is="frame" data-translation={`${navArticleWidth}`}>
    {
      locations.map((loc) => {
        return (
          <article class={`vertical gap-3 justify-between`} style="min-width : var(--navArticleWidth);">
            <div class="horizontal items-center justify-start w-fit gap-1 text-[0.95rem]">
              <output class="tabular-nums text-white font-semibold">{loc.labelPage}</output>
              <span class="text-white/90">/ {totalPages}</span>
            </div>
            <header>
              <h3 class="text-2xl font-medium leading-3">{loc.title}</h3>
              <small class="text-sm text-white/90 whitespace-nowrap w-full">{loc.subtitle}</small>
            </header>
            <nav class="horizontal items-center justify-start gap-2 mt-1">
              <button data-is="map-nav" data-action={`prev#${loc.page}#${totalPages}`} class="hover:[&>*]:text-white">
                <ArrowLeft className="text-white/90" />
              </button>
              <button data-is="map-nav" data-action={`next#${loc.page}#${totalPages}`} class="hover:[&>*]:text-white">
                <ArrowRight className="text-white/90" />
              </button>
            </nav>
          </article>
        );
      })
    }
  </div>
</div>
<div id="canvas-ctn" class="absolute-align full [&>div]:w-fit pointer-events-none">
  <canvas id="locationCanvas" data-hidden></canvas>
  {
    locations.map((loc, i) => {
      return (
        <div class="horizontal center gap-2 absolute" data-coor={loc.coordinates} data-index={i}>
          <LocationMark selected={loc.selected}>{loc.label || loc.title}</LocationMark>
        </div>
      );
    })
  }
</div>
